<!DOCTYPE html>
<!--[if IE 7]>
<html class="ie ie7" lang="en-US" prefix="og: http://ogp.me/ns#">
<![endif]-->
<!--[if IE 8]>
<html class="ie ie8" lang="en-US" prefix="og: http://ogp.me/ns#">
<![endif]-->
<!--[if !(IE 7) | !(IE 8)  ]><!-->
<html lang="en-US" prefix="og: http://ogp.me/ns#" >

<!--<![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>Introduction to Programming Paradigms</title>
<div id="primary" class="site-content">

		<div id="content" role="main">

                        							 	<article id="post-234731" class="post-234731 post type-post status-publish format-standard hentry category-design-pattern category-guestblogs tag-object-oriented-design tag-picked tag-technical-scripter-2018">

				<header class="entry-header">

						<h1 class="entry-title"><center><u>Introduction to Programming Paradigms</u></center></h1>

				

						</header><!-- .entry-header -->



				<div class="entry-content">

<p align="right"><b>By Chitkala</b></p>

<p align="right"><b>RA1811028010088</b></p>

<p align="right"><b>CSE J2</b></p>

			<p><b>Paradigm</b> can also be termed as method to solve some problem or do some task. Programming paradigm is an approach to solve problem using some programming language or also we can say it is a method to solve a problem using tools and techniques that are available to us following some approach. There are lots for programming language that are known but all of them need to follow some strategy when they are implemented and this methodology/strategy is paradigms. Apart from varieties of programming language there are lots of paradigms to fulfil each and every demand. They are discussed below:</p>


			<p><b>1. Structured Programming Paradigm &#8211;</b><br />
				As the word suggests, can be defined as a programming paradigm in which the program is made as a single structure. It means that the code will execute the instruction by instruction one after the other. It doesn’t support the possibility of jumping from one instruction to some other with the help of any statement like GOTO, etc. Therefore, the instructions in this approach will be executed in a serial and structured manner. The languages that support Structured programming paradigm are:
				</p>
<ul>
<li>C</li>
<li>C++</li>
<li>Java</li>
<li>C# ..etc</li>
</ul>
	<p>The structured program mainly consists of three types of elements:</p>

<ul>

<li>Selection Statements</li>

<li>Sequence Statements</li>

<li>Iteration Statements</li>

</ul>

<p>The structured program consists of well structured and separated modules. But the entry and exit in a Structured program is a single-time event. It means that the program uses single-entry and single-exit elements. Therefore a structured program is well maintained, neat and clean program. This is the reason why the Structured Programming Paradigm is well accepted in the programming world.</p>

<p><b>Advantages:</b></p>

<ul>

<li>Easier to read and understand</li>

<li>User Friendly</li>

<li>Easier to Maintain</li>

<li>Mainly problem based instead of being machine based</li>

<li>Development is easier as it requires less effort and time</li>

<li>Easier to Debug</li>

<li>Machine-Independent, mostly.</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

<li>Since it is Machine-Independent, So it takes time to convert into machine code.</li>

<li>The converted machine code is not the same as for assembly language.</li>

<li>The program depends upon changeable factors like data-types. Therefore it needs to be updated with the need on the go.</li>

<li>Usually the development in this approach takes longer time as it is language-dependent. Whereas in the case of assembly language, the development takes lesser time as it is fixed for the machine.</li>

</ul>

<p><b>2.Procedural Programming Paradigm &#8211;</b><br />
	This paradigm emphasizes on procedure  in terms of under lying machine model. There is no difference in between procedural and imperative approach. It has the ability to reuse the code and it was boon at that time when it was in use because of its reusability.</p>
<p>
In procedural programming data and functions are separate. A program is typically designed in a top-down (or in some cases bottom-up) manner using functional decomposition, or step-wise refinement. The resulting structure of a program can be viewed as a hierarchy or tree-like structure. Functions and data structures are the fundamental abstractions, but they remain separate. Data structures (typically) only contain data. They are passed as arguments to functions, with the functions using or modifying the data. Languages such as BASIC, Pascal and C are examples of procedural languages.</p>
	

<p><b>Advantages:</b></p>

<ul>

<li>Its relative simplicity, and ase of implementation of compilers and interpretors.

</li>

<li>An easier way to keep track of program flow.

</li>

<li>The ability to be strongly modular or structured.

	</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

<li>Data is exposed to whole program, so no security of data.

</li>

<li>Difficult to create new data types reduces extensibility

</li>

</ul>

<p><b>3.Object Oriented Programming Paradigm &#8211;</b><br />

The program is written as a collection of classes and object which are meant for communication. The smallest and basic entity is object and all kind of computation is performed on the objects only. More emphasis is on data rather procedure. It can handle almost all kind of real life problems which are today in scenario.</p>

<p><b>Advantages:</b></p>

<ul>

<li>Data security

</li>

<li>Inheritance

</li>

<li>Code reusability

</li>

<li>Flexible and abstraction is also present

</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

	<li>Designing and proper implementation of Object Oriented Programming concepts is complex and burdensome.

</li>

<li> Programs of object-oriented programming are of larger size in comparison with the traditional procedural programming.

	</li>

	<li> Due to large size of the programs its execution speed becomes slow.

	</li>
</ul>

<p><b>4.Event Driven Programming Paradigm &#8211;</b><br />
Event-driven programming is a programming paradigm in which the flow of program execution is determined by events - for example a user action such as a mouse click, key press, or a message from the operating system or another program. An event-driven application is designed to detect events as they occur, and then deal with them using an appropriate event-handling procedure.</p>

<p>In a typical modern event-driven program, there is no discernible flow of control. The main routine is an event-loop that waits for an event to occur, and then invokes the appropriate event-handling routine. Since the code for this event loop is usually provided by the event-driven development environment or framework, and largely invisible to the programmer, the programmer’s perception of the application is that of a collection of event handling routines.</p>

<p><b>Advantages:</b></p>

<ul>

	<li>Programmes which are event driven can be put together without any problems and also the program can be easily altered because if something isn't right then it will let the user to change a piece of code or moving different tools around the form.
	</li>

	<li>It lets the programmer to produce a form to their requirements. Also provides the programmer to be in charge.
	</li>
</ul>

<p><b>Disadvantages:</b></p>

<ul>

	<li>Classes are often not reusable or hard to implement in other applications.
	</li>

	<li>Is often not portable to other operating systems, such as in the case of the .NET framework under windows that uses event driven programming.

	</li>
</ul>

<p><b>5.Declarative Programming Paradigm &#8211;</b><br />

In computer science the decarative programming is a style of building programs that expresses logic of computation without talking about its control flow. It often considers programs as theories of some logic.It may simplify writing parallel programs. The focus is on what needs to be done rather how it should be done basically emphasize on what code code is actually doing. It just declare the result we want rather how it has be produced. This is the only difference between imperative (how to do) and declarative (what to do) programming paradigms.</p>

<p><b>Advantages:</b></p>

<ul>
	<li>Can be implemented using methods not yet known at the time of programming.</li>
	<li>Easy optimization as implementation is controlled by an algorithm.</li>
</ul>

<p><b>Disadvantages:</b></p>

<ul>

	<li>Sometimes hard to understand for external people.</li>
	<li>Hard to take characteristics of individual applications into account during programming.</li>
</ul>


			<p><b>6.Imperative programming paradigm &#8211;</b><br />

It is one of the oldest programming paradigm. It features close relation relation to machine architecture. It is based on Von Neumann architecture. It works by changing  the program state through assignment statements. It performs step by step task by changing state. The main focus is on how to achieve the goal. The paradigm consist of several statements and after execution of all the result is stored.</p>



<p><b>Advantages:</b></p>

<ul>

<li>Very simple to implement

</li>

<li>It contains loops, variables etc.

</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

<li>Complex problem cannot be solved

</li>

<li>Less efficient and less productive</li>

<li>Parallel Programming is not possible

</li>

</ul>


<p><b>7.Parallel Programming Paradigm &#8211;</b><br />

Parallel processing is the processing of program instructions by dividing them among multiple processors. A parallel processing system posses many numbers of processor with the objective of running a program in less time by dividing them. This approach seems to be like divide and conquer.</p>

<p>In computing, a parallel programming model is an abstraction of parallel computer architecture, with which it is convenient to express algorithms and their composition in programs. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently the compiled programs can execute.The implementation of a parallel programming model can take the form of a library invoked from a sequential language, as an extension to an existing language, or as an entirely new language.</p>

 <p>Examples are NESL (one of the oldest one) and C/C++ also supports because of some library function.</p>

<p><b>8.Concurrent Programming Paradigm &#8211;</b><br />

In a concurrent program, several streams of operations may execute concurrently. Each stream of operations executes as it would in a sequential program except for the fact that streams can communicate and interfere with one another. Each such sequence of instructions is called a thread. For this reason, sequential programs are often called single-threaded programs. When a multi-threaded program executes, the operations in its various threads are interleaved in an unpredictable order subject to the constraints imposed by explicit synchronization operations that may be embedded in the code. The operations for each stream are strictly ordered, but the interleaving of operations from a collection of streams is undetermined and depends on the vagaries of a particular execution of the program. </p>


<p><b>Advantages:</b></p>

<ul>

<li>User can interact with applications while tasks are running, e.g., stopping the transfer of a big file in a web browser.

</li>

<li>– Tasks requiring certain preconditions can suspend and wait until the preconditions hold, then resume execution transparently.

</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

<li>Threads can be expensive. Overhead of scheduling, context-switching, and synchronization.

</li>

<li>Concurrent programs can run slower than their sequential counterparts even with multiple CPUs.</li>

</ul>

<p><b>9.Functional Programming Paradigm &#8211;</b><br />

The functional programming paradigms has its roots in mathematics and it is language independent. The key principal of this paradigms is the execution of series of mathematical functions. The central model for the abstraction is the function which are meant for some specific computation and not the data structure. Data are loosely coupled to functions.The function hide their implementation. Function can be replaced with their values without changing the meaning of the program. Some of the languages like perl, javascript mostly uses this paradigm.</p>

<pre>Examples of <b>Functional</b> programming paradigm:



<b>JavaScript</b>

<b>Haskwell</b>

<b>Scala</b>

<b>Erlang</b>

<b>Lisp</b> 

<b>ML</b>

<b>Clojure</b> </pre>


<p><b>Advantages:</b></p>

<ul>

<li>Debugging is easier.

</li>

<li>Parallel/concurrent programming is easier.

</li>

</ul>

<p><b>Disadvantages:</b></p>

<ul>

<li>Recursion is very expensive to use.

</li>

<li>Difficulty of stateful programming.</li>

<li>Non-functionality of computers.

</li>

</ul>


<p><b>10.Logic Programming Paradigm &#8211;</b><br />

It can be termed as abstract model of computation. It would solve logical problems like puzzles, series etc. In logic programming we have a knowledge base which we know before and along with the question and knowledge base which is given to machine, it produces result. In normal programming languages, such concept of knowledge base is not available but while using the concept of artificial intelligence, machine learning we have some models like Perception model which is using the same mechanism.<br />

In logical programming the main emphasize is on knowledge base and the problem. The execution of the program is very much like proof of mathematical statement, e.g., Prolog</p>

<pre>sum of two number in prolog:



  predicates

  sumoftwonumber(integer, integer)

clauses



  sum(0, 0).

   sum(n, r):-

        n1=n-1,

        sum(n1, r1),

        r=r1+n </pre>

<p><b>11.Dependent Type Programming Paradigm &#8211;</b><br />

	 A Dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems. In intuitionistic type theory, dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda, ATS, Coq, F*, Epigram, and Idris, dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.</p>

<p>Two common examples of dependent types are dependent functions and dependent pairs. The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer {\displaystyle n}n may return an array of length {\displaystyle n}n, where the array length is part of the type of the array. A dependent pair may have a second value of which the type depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.</p>


	<p>Dependent types were created to deepen the connection between programming and logic. </p> 

	<p><b>12.Network Programming Paradigm &#8211;</b><br />

	The Network paradigm involves thinking of computing in terms of a client, who is essentially in need of some type of information, and a server, who has lots of information and is just waiting to hand it out. Typically, a client will connect to a server and query for certain information. The server will go off and find the information and then return it to the client.</p>
<p>In the context of the Internet, clients are typically run on desktop or laptop computers attached to the Internet looking for
information, whereas servers are typically run on larger computers with certain types of information available for the clients to
retrieve. The Web itself is made up of a bunch of computers that act as Web servers; they have vast amounts of HTML pages and
related data available for people to retrieve and browse. Web clients are used by those of us who connect to the Web servers and
browse through the Web pages.</p>

<p>Network programming uses a particular type of network communication known as sockets. A socket is a software abstraction for an
input or output medium of communication.</p> 

<p><b>13.Symbolic Programming Paradigm &#8211;</b><br />

	In computer programming, symbolic programming is a programming paradigm in which the program can manipulate its own formulas and program components as if they were plain data.</p>

<p>Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to "learn", which makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.</p>

<p>Languages that support symbolic programming include homoiconic languages such as Wolfram Language, LISP and Prolog.</p>

<p><b>14.Automata Based Programming Paradigm &#8211;</b><br />
Automata-based programming is a programming paradigm in which the program or part of it is thought of as a model of a finite-state machine (FSM) or any other (often more complicated) formal automaton. Sometimes a potentially infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration.</p>

<p><b>Automata theory</b></p>
<ul>
	<li>Automata theory is the study of abstract computational devices.</li>

	<li>Abstract devices are (simplified) models of real computations </li>

	<li>Computations happen everywhere: On your laptop, on your cell phone, in nature ..etc.</li>
</ul>

<p><b>Types of Automata</b></p>

<ul>
	<li>Finite Automata- Devices with a finite amount of memory.</li>

	<li>Push-down Automata- Devices with infinite memory that can be accessed in a restricted way.</li>

	<li>Turing Machines- Devices with infinite memory.</li>
</ul>

<p><b>15.Graphical User Interface Programming Paradigm &#8211;</b><br />

A Graphic User Interface is a form of user interface that allows users to interact with electronic devices through graphical icons and audio indicator such as primary notation, instead of text-based user interfaces, typed command labels or text navigation. GUIs were introduced in reaction to the perceived steep learning curve of command-line interfaces (CLIs),[3][4][5] which require commands to be typed on a computer keyboard.</p>

<p>The actions in a GUI are usually performed through direct manipulation of the graphical elements.[6][7][8] Beyond computers, GUIs are used in many handheld mobile devices such as MP3 players, portable media players, gaming devices, smartphones and smaller household, office and industrial controls. </p>

<p><b>Advantages:</b></p>

<ul>
	<li>A major advantage of GUIs is that they make computer operation more intuitive, and thus easier to learn and use.</li>

	<li>GUI allows multiple programs and/or instances to be displayed simultaneously.</li>

	<li>GUIs generally provide users with immediate, visual feedback about the effect of each action.</li>
</ul>

<p><b>Disadvantages:</b></p>

<ul>
	<li>GUI take up a much larger amount of hard disk space than other interfaces.</li>

	<li>They need significantly more memory (RAM) to run than other interface types.</li>

	<li>They use more processing power than other types of interface.</li>
</ul>



</body>

</html>